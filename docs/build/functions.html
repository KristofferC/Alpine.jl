<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · POD</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>POD</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="intro.html">Introduction</a></li><li><a class="toctext" href="installation.html">Installation</a></li><li><a class="toctext" href="demo.html">Demo</a></li><li><a class="toctext" href="parameters.html">Parameters</a></li><li><a class="toctext" href="choosingsolver.html">Choosing Solvers</a></li><li class="current"><a class="toctext" href="functions.html">Methods</a><ul class="internal"><li><a class="toctext" href="#High-level-Algorithmic-Operations-1">High-level Algorithmic Operations</a></li><li><a class="toctext" href="#Adapative-Partitioning-Methods-1">Adapative Partitioning Methods</a></li><li><a class="toctext" href="#Presolve-Methods-1">Presolve Methods</a></li><li><a class="toctext" href="#Utility-Methods-1">Utility Methods</a></li></ul></li><li><a class="toctext" href="hacking.html">Hacking</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="functions.html">Methods</a></li></ul><a class="edit-page" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/docs/src/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><h2><a class="nav-anchor" id="High-level-Algorithmic-Operations-1" href="#High-level-Algorithmic-Operations-1">High-level Algorithmic Operations</a></h2><p>These are the high-level algorithmic methods:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.presolve" href="#POD.presolve"><code>POD.presolve</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">presolve(m::PODNonlinearModel)</code></pre><p>Function that perfoms a presolve on the user-supplied nonlinear program. The presolve first provides the model to a local solver to obtain an initial feasible solution. If the local solver returns a feasible solution then the objective value of the feasible solution is used in conjunction with the original model for a bound-tightening procedure. If the local solver reports infeasibililty the bound-tightening procedure does not use the objective value. Furthermore, in this case, a second local solve is attempted using the tightened bounds.</p><p>If a local solution is not obtained eved after the second solve then an initial McCormick solve is performed. The local solution (if available) or the initial McCormick solution (if infeasible after two local solve tries) is then used to partition the variables for the subsequent Adaptive Multivariate Partitioning algorithm iterations.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/algorithm.jl#L254-L269">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.global_solve" href="#POD.global_solve"><code>POD.global_solve</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">global_solve(m::PODNonlinearModel)</code></pre><p>Perform the global algorithm that is based on the adaptive conexification scheme. This iterative algorithm loops over <a href="functions.html#POD.bounding_solve"><code>bounding_solve</code></a> and <a href="functions.html#POD.local_solve"><code>local_solve</code></a> for converging lower bound (relaxed problem) and upper bound (feasible problem). Each <a href="functions.html#POD.bounding_solve"><code>bounding_solve</code></a> provides a lower bound solution that is used as a partioning point for next iteration (this feature can be modified given different <code>add_discretization</code>). Each <a href="functions.html#POD.local_solve"><code>local_solve</code></a> provides a local serach of incumbent feasible solution. The algrithm terminates given time limits, optimality condition, or iteration limits.</p><p>The algorithm is can be reformed when <code>add_discretization</code> is replaced with user-defined functional input. For example, this algorithm can easily be reformed as a uniform-partitioning algorithm in other literature.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/algorithm.jl#L317-L329">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.local_solve" href="#POD.local_solve"><code>POD.local_solve</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">local_solve(m::PODNonlinearModel, presolve::Bool=false)</code></pre><p>Perform a local NLP or MINLP solve to obtain a feasible solution. The <code>presolve</code> option is set to <code>true</code> when the function is invoked in <a href="functions.html#POD.presolve"><code>presolve</code></a>. Otherwise, the function is invoked from <a href="functions.html#POD.bounding_solve"><code>bounding_solve</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/algorithm.jl#L347-L355">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.bounding_solve" href="#POD.bounding_solve"><code>POD.bounding_solve</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bounding_solve(m::PODNonlinearModel; kwargs...)</code></pre><p>This is a solving process usually deal with a MIP or MIQCP problem for lower bounds of problems. It solves the problem built upon a convexification base on a discretization Dictionary of some variables. The convexification utilized is Tighten McCormick scheme. See <code>create_bounding_mip</code> for more details of the problem solved here.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/algorithm.jl#L413-L422">source</a><br/></section><h2><a class="nav-anchor" id="Adapative-Partitioning-Methods-1" href="#Adapative-Partitioning-Methods-1">Adapative Partitioning Methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.create_bounding_mip" href="#POD.create_bounding_mip"><code>POD.create_bounding_mip</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">create_bounding_mip(m::PODNonlinearModel; use_discretization::Dict)</code></pre><p>Set up a JuMP MILP bounding model base on variable domain partitioning information stored in <code>use_discretization</code>. By default, if <code>use_discretization is</code> not provided, it will use <code>m.discretizations</code> store in the POD model. The basic idea of this MILP bounding model is to use Tighten McCormick to convexify the original Non-convex region. Among all presented partitionings, the bounding model will choose one specific partition as the lower bound solution. The more partitions there are, the better or finer bounding model relax the original MINLP while the more efforts required to solve this MILP is required.</p><p>This function is implemented in the following manner:</p><pre><code class="language-none">* [`post_amp_vars`](@ref): post original and lifted variables
* [`post_amp_lifted_constraints`](@ref): post original and lifted constraints
* [`post_amp_lifted_obj`](@ref): post original or lifted objective function
* [`post_amp_mccormick`](@ref): post Tighen McCormick variables and constraints base on `discretization` information</code></pre><p>More specifically, the Tightening McCormick used here can be genealized in the following mathematcial formulation. Consider a nonlinear term</p><div>\[\begin{subequations}
\begin{align}
   &amp;\widehat{x_{ij}} \geq (\mathbf{x}_i^l\cdot\hat{\mathbf{y}}_i) x_j + (\mathbf{x}_j^l\cdot\hat{\mathbf{y}}_j) x_i - (\mathbf{x}_i^l\cdot\hat{\mathbf{y}}_i)(\mathbf{x}_j^l\cdot\hat{\mathbf{y}}_j) \\
   &amp;\widehat{x_{ij}} \geq (\mathbf{x}_i^u\cdot\hat{\mathbf{y}}_i) x_j + (\mathbf{x}_j^u\cdot\hat{\mathbf{y}}_j) x_i - (\mathbf{x}_i^u\cdot\hat{\mathbf{y}}_i)(\mathbf{x}_j^u\cdot\hat{\mathbf{y}}_j) \\
   &amp;\widehat{x_{ij}} \leq (\mathbf{x}_i^l\cdot\hat{\mathbf{y}}_i) x_j + (\mathbf{x}_j^u\cdot\hat{\mathbf{y}}_j) x_i - (\mathbf{x}_i^l\cdot\hat{\mathbf{y}}_i)(\mathbf{x}_j^u\cdot\hat{\mathbf{y}}_j) \\
   &amp;\widehat{x_{ij}} \leq (\mathbf{x}_i^u\cdot\hat{\mathbf{y}}_i) x_j + (\mathbf{x}_j^l\cdot\hat{\mathbf{y}}_j) x_i - (\mathbf{x}_i^u\cdot\hat{\mathbf{y}}_i)(\mathbf{x}_j^l\cdot\hat{\mathbf{y}}_j) \\
   &amp; \mathbf{x}_i^u\cdot\hat{\mathbf{y}}_i) \geq x_{i} \geq \mathbf{x}_i^l\cdot\hat{\mathbf{y}}_i) \\
   &amp; \mathbf{x}_j^u\cdot\hat{\mathbf{y}}_j) \geq x_{j} \geq \mathbf{x}_j^l\cdot\hat{\mathbf{y}}_j) \\
   &amp;\sum \hat{\mathbf{y}_i} = 1, \ \ \sum \hat{\mathbf{y}_j}_k = 1 \\
   &amp;\hat{\mathbf{y}}_i \in \{0,1\}, \hat{\mathbf{y}}_j \in \{0,1\}
\end{align}
\end{subequations}\]</div></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/model.jl#L1-L35">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.pick_vars_discretization" href="#POD.pick_vars_discretization"><code>POD.pick_vars_discretization</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pick_vars_discretization(m::PODNonlinearModel)</code></pre><p>This function helps pick the variables for discretization. The method chosen depends on user-inputs. In case when <code>indices::Int</code> is provided, the method is chosen as built-in method. Currently, there exist two built-in method:</p><pre><code class="language-none">* `max-cover(m.discretization_var_pick_algo=0, default)`: pick all variables involved in the non-linear term for discretization
* `min-vertex-cover(m.discretization_var_pick_algo=1)`: pick a minimum vertex cover for variables involved in non-linear terms so that each non-linear term is at least convexified</code></pre><p>For advance usage, <code>m.discretization_var_pick_algo</code> allows <code>::Function</code> inputs. User is required to perform flexible methods in choosing the non-linear variable. For more information, read more details at <a href="hacking.html#Hacking-Solver-1">Hacking Solver</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/model.jl#L57-L70">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.fix_domains" href="#POD.fix_domains"><code>POD.fix_domains</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fix_domains(m::PODNonlinearModel)</code></pre><p>This function is used to fix variables to certain domains during the local solve process in the <a href="functions.html#POD.global_solve"><code>global_solve</code></a>. More specifically, it is used in <a href="functions.html#POD.local_solve"><code>local_solve</code></a> to fix binary and integer variables to lower bound solutions and discretizing varibles to the active domain according to lower bound solution.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/utility.jl#L211-L219">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.min_vertex_cover" href="#POD.min_vertex_cover"><code>POD.min_vertex_cover</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">min_vertex_cover(m:PODNonlinearModel)</code></pre><p>A built-in method for selecting variables for discretization.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/model.jl#L158-L164">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.max_cover" href="#POD.max_cover"><code>POD.max_cover</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">max_cover(m:PODNonlinearModel)</code></pre><p>A built-in method for selecting variables for discretization. It selects all variables in the nonlinear terms.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/model.jl#L199-L205">source</a><br/></section><h2><a class="nav-anchor" id="Presolve-Methods-1" href="#Presolve-Methods-1">Presolve Methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.bound_tightening" href="#POD.bound_tightening"><code>POD.bound_tightening</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bound_tightening(m::PODNonlinearModel)</code></pre><p>Entry point for the bound-tightening algorithm. The aim of the bound-tightening algorithm is to tighten the variable bounds, if possible.</p><p>Currently, two bounding tightening method is implemented <a href="functions.html#POD.minmax_bound_tightening"><code>minmax_bound_tightening</code></a>.</p><pre><code class="language-none">* Bound-tightening with basic McCormick
* Bound-tightening with McCormick partitions: (3 partitions around the local feasible solution)
If no local feasible solution is obtained, the algorithm defaults to bound-tightening with basic McCormick</code></pre></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/presolve.jl#L1-L14">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.minmax_bound_tightening" href="#POD.minmax_bound_tightening"><code>POD.minmax_bound_tightening</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">minmax_bound_tightening(m:PODNonlinearModel; use_bound::Bool=true, use_tmc::Bool)</code></pre><p>This function implements the bound-tightening algorithm to tighten the variable bounds. It utilizes either the basic McCormick relaxation or the Tightened McCormick relaxation (TMC) to tighten the bounds. The TMC has additional binary variables for partitioning.</p><p>The algorithm as two main parameters. The first is the <code>use_tmc</code>, which when set to <code>true</code> invokes the algorithm on the TMC relaxation. The second parameter <code>use_bound</code> takes in the objective value of the local solve solution stored in <code>best_sol</code>. The <code>use_bound</code> option is set to <code>true</code> when the local solve is successful is obtaining a feasible solution and the bound-tightening is to be performed using the objective value of the feasible solution, else this parameter is set to <code>false</code></p><p>Several other parameters are available for the presolve algorithm tuning. For more details, see <a href="parameters.html#Parameters-1">Parameters</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/presolve.jl#L34-L52">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.create_bound_tightening_model" href="#POD.create_bound_tightening_model"><code>POD.create_bound_tightening_model</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">create_bound_tightening_model(m::PODNonlinearModel, discretization::Dict, bound::Float64)</code></pre><p>This function takes in the initial discretization information and builds a bound-tightening model. It is an algorithm specific function called by <a href="functions.html#POD.minmax_bound_tightening"><code>minmax_bound_tightening</code></a></p><p><strong></strong></p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/presolve.jl#L127-L133">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.solve_bound_tightening_model" href="#POD.solve_bound_tightening_model"><code>POD.solve_bound_tightening_model</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">solve_bound_tightening_model(m::PODNonlinearModel)</code></pre><p>A function that solves the min and max bound-tightening model.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/presolve.jl#L155-L161">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.resolve_lifted_var_bounds" href="#POD.resolve_lifted_var_bounds"><code>POD.resolve_lifted_var_bounds</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">resolve_lifted_var_bounds(nonlinear_info::Dict, discretization::Dict)</code></pre><p>For discretization to be performed, we do not allow for a variable being discretized to have infinite bounds. The lifted variables will have infinite bounds and the function infers bounds on these variables. This process can help speed up the subsequent solve in subsequent iterations.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/presolve.jl#L181-L187">source</a><br/></section><h2><a class="nav-anchor" id="Utility-Methods-1" href="#Utility-Methods-1">Utility Methods</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.update_var_bounds" href="#POD.update_var_bounds"><code>POD.update_var_bounds</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">update_var_bounds(m::PODNonlinearModel, discretization::Dict; len::Float64=length(keys(discretization)))</code></pre><p>This function take in a dictionary-based discretization information and convert them into two bounds vectors (l_var, u_var) by picking the smallest and largest numbers. User can specify a certain length that may contains variables that is out of the scope of discretization.</p><p>Output::</p><pre><code class="language-none">l_var::Vector{Float64}, u_var::Vector{Float64}</code></pre></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/utility.jl#L1-L9">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.discretization_to_bounds" href="#POD.discretization_to_bounds"><code>POD.discretization_to_bounds</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">discretization_to_bounds(d::Dict, l::Int)</code></pre><p>Same as <a href="functions.html#POD.update_var_bounds"><code>update_var_bounds</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/utility.jl#L27-L31">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.initialize_discretization" href="#POD.initialize_discretization"><code>POD.initialize_discretization</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">initialize_discretization(m::PODNonlinearModel)</code></pre><p>This function initialize the dynamic discretization used for any bounding models. By default, it takes (.l_var_orig, .u_var_orig) as the base information. User is allowed to use alternative bounds for initializing the discretization dictionary. The output is a dictionary with MathProgBase variable indices keys attached to the :PODNonlinearModel.discretization.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/utility.jl#L34-L39">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.to_discretization" href="#POD.to_discretization"><code>POD.to_discretization</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">to_discretization(m::PODNonlinearModel, lbs::Vector{Float64}, ubs::Vector{Float64})</code></pre><p>Utility functions to convert bounds vectors to Dictionary based structures that is more suitable for partition operations.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/utility.jl#L59-L66">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.flatten_discretization" href="#POD.flatten_discretization"><code>POD.flatten_discretization</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">flatten_discretization(discretization::Dict)</code></pre><p>Utility functions to eliminate all partition on discretizing variable and keep the loose bounds.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/utility.jl#L87-L92">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.add_discretization" href="#POD.add_discretization"><code>POD.add_discretization</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">add_discretization(m::PODNonlinearModel; use_discretization::Dict, use_solution::Vector)</code></pre><p>Basic built-in method used to add a new partition on feasible domains of discretizing variables. This method make modification in .discretization</p><p>Consider original partition [0, 3, 7, 9], where LB/any solution is 4. Use ^ as the new partition, &quot;|&quot; as the original partition</p><p>A case when discretize ratio = 4 | –––– | - ^ – * – ^ –– | –––– | 0          3  3.5   4   4.5     7          9</p><p>A special case when discretize ratio = 2 | –––– | –– * –– ^ –– | –––– | 0          3      4      5      7          9</p><p>There are two options for this function,</p><pre><code class="language-none">* `use_discretization(default=m.discretization)`:: to regulate which is the base to add new partitions on
* `use_solution(default=m.best_bound_sol)`:: to regulate which solution to use when adding new partitions on</code></pre><p>This function belongs to the hackable group, which means it can be replaced by the user to change the behvaior of the solver.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/utility.jl#L103-L126">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.update_mip_time_limit" href="#POD.update_mip_time_limit"><code>POD.update_mip_time_limit</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">update_mip_time_limit(m::PODNonlinearModel)</code></pre><p>An utility function used to dynamically regulate MILP solver time limits to fit POD solver time limits.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/utility.jl#L166-L172">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="POD.fetch_timeleft_symbol" href="#POD.fetch_timeleft_symbol"><code>POD.fetch_timeleft_symbol</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fetch_timeleft_symbol(m::PODNonlinearModel)</code></pre><p>An utility function used to recognize differnt sub-solvers return the timelimit setup keywords.</p></div><a class="source-link" target="_blank" href="https://github.com/lanl-ansi/POD/tree/02c48ab8d7c532827c406d56c5a677906d5899a2/src/utility.jl#L192-L197">source</a><br/></section><footer><hr/><a class="previous" href="choosingsolver.html"><span class="direction">Previous</span><span class="title">Choosing Solvers</span></a><a class="next" href="hacking.html"><span class="direction">Next</span><span class="title">Hacking</span></a></footer></article></body></html>
